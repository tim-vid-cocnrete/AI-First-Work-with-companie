# Транскрипт Технического Интервью
*[ПРИМЕР ШАБЛОНА - Это вымышленный транскрипт технического интервью для демонстрационных целей]*

**Кандидат:** Michael Thompson
**Интервьюеры:** David Martinez (Senior Analyst), Amanda Rodriguez (Technical Lead)
**Дата:** 28 Марта 2024
**Длительность:** 45 минут
**Позиция:** Senior Marketing Analyst

---

## Техническая Оценка: Навыки SQL

**David Martinez:** Привет, Майкл, спасибо, что присоединились к нам для технического раунда. Мы протестируем ваши навыки SQL на некоторых практических сценариях, похожих на то, с чем вы столкнетесь в нашей ежедневной работе.

Позвольте мне поделиться экраном с нашей тестовой базой данных. У нас есть четыре таблицы: companies, passengers, passenger_trips и trips. Видите схему?

**Michael Thompson:** Да, вижу. Похоже на систему бронирования полетов.

**David Martinez:** Именно. Давайте начнем с чего-то прямолинейного. Можете написать запрос, чтобы найти все компании, у которых было более 5 полетов в Мае 2024?

**Michael Thompson:** Конечно, дайте подумать... Мне нужно соединить trips с companies и отфильтровать по дате.

```sql
SELECT c.company_name, COUNT(t.trip_id) as flight_count
FROM companies c
JOIN trips t ON c.company_id = t.company_id  
WHERE t.departure_time >= '2024-05-01' 
  AND t.departure_time < '2024-06-01'
GROUP BY c.company_name
HAVING COUNT(t.trip_id) > 5;
```

**David Martinez:** Хороший подход. Одно небольшое замечание - вы, возможно, захотите указать GROUP BY с company_id также для лучшей практики, но это работает.

Теперь давайте усложним. Можете найти пассажиров, которые совершили ровно 3 или более полетов с одной и той же компанией, и перечислить этих пассажиров с их компанией?

**Michael Thompson:** Хм, это сложнее. Мне нужно... дайте посмотреть...

```sql
SELECT p.passenger_name, c.company_name, COUNT(*) as trips_count
FROM passengers p
JOIN passenger_trips pt ON p.passenger_id = pt.passenger_id
JOIN trips t ON pt.trip_id = t.trip_id  
JOIN companies c ON t.company_id = c.company_id
GROUP BY p.passenger_id, c.company_id
HAVING COUNT(*) >= 3;
```

**Amanda Rodriguez:** Это на правильном пути. Вы правильно соединяете все таблицы. Однако вы группируете по passenger_id и company_id, но выбираете passenger_name и company_name. Какую проблему это может вызвать?

**Michael Thompson:** О, точно... Я должен включить ID в GROUP BY или использовать ID в SELECT. В некоторых базах данных это вызвало бы ошибку.

**Amanda Rodriguez:** Именно. Давайте исправим это. Также я заметила, что вы использовали COUNT(*) - это лучший выбор здесь?

**Michael Thompson:** Я мог бы использовать COUNT(pt.trip_id), чтобы быть более явным, хотя COUNT(*) должно работать нормально, так как мы соединяем по не-null значениям.

**David Martinez:** Давайте перейдем к более сложному сценарию. Мы хотим проанализировать самый популярный самолет для каждой компании. Можете написать запрос, который показывает каждую компанию с их наиболее часто используемым типом самолета, вместе с количеством полетов для этого самолета?

**Michael Thompson:** Это становится хитро... Мне нужно найти максимальное количество для каждой компании. Дайте я попробую использовать оконную функцию...

```sql
SELECT company_name, aircraft_type, flight_count
FROM (
  SELECT c.company_name, t.aircraft_type, 
         COUNT(*) as flight_count,
         ROW_NUMBER() OVER (PARTITION BY c.company_id ORDER BY COUNT(*) DESC) as rn
  FROM companies c
  JOIN trips t ON c.company_id = t.company_id
  GROUP BY c.company_id, c.company_name, t.aircraft_type
) ranked
WHERE rn = 1;
```

**Amanda Rodriguez:** Это солидный подход с использованием оконных функций! Однако есть одна потенциальная проблема - что если два типа самолетов имеют одинаковое количество для компании?

**Michael Thompson:** О, ROW_NUMBER выбрал бы только один произвольно. Я мог бы использовать RANK() вместо этого, чтобы показать ничьи, но тогда мне нужно было бы обработать несколько строк для компании...

**Amanda Rodriguez:** Именно. Это те виды граничных случаев, с которыми мы имеем дело регулярно. Насколько комфортно вы себя чувствуете с более продвинутыми концепциями SQL, такими как CTE, рекурсивные запросы или оптимизация для больших наборов данных?

**Michael Thompson:** Я знаком с CTE концептуально и использовал их на практике несколько раз. Рекурсивные запросы и оптимизация производительности - это области, где мне определенно нужно больше опыта. Я в основном работал с относительно небольшими наборами данных.

## Обсуждение Логики Атрибуции

**David Martinez:** Давайте переключимся на сценарий маркетинговой атрибуции. У нас есть данные Google Analytics, показывающие сессии пользователей, и отдельные данные заказов. Как бы вы подошли к построению атрибуции по последнему клику, но с правилом, что если использовался промокод от инфлюенсера, мы атрибутируем этому инфлюенсеру вместо этого?

**Michael Thompson:** Мне нужно было бы соединить сессии с заказами по ID пользователя и временной метке, получить последнюю сессию перед каждым заказом, но затем переопределить атрибуцией промокода, если он присутствует.

Что-то вроде:
1. Получить все заказы с их временными метками
2. Для каждого заказа найти последнюю сессию перед этим заказом
3. Если у заказа есть промокод, использовать эту атрибуцию вместо источника сессии

**Amanda Rodriguez:** Это правильная логика. Можете набросать структуру SQL для шага 2 - поиска последней сессии перед каждым заказом?

**Michael Thompson:** Я думаю, я бы использовал оконную функцию...

```sql
WITH order_sessions AS (
  SELECT o.order_id, o.user_id, o.order_time,
         s.session_id, s.session_time, s.source,
         ROW_NUMBER() OVER (PARTITION BY o.order_id ORDER BY s.session_time DESC) as rn
  FROM orders o
  LEFT JOIN sessions s ON o.user_id = s.user_id 
                      AND s.session_time < o.order_time
)
SELECT order_id, session_id, source
FROM order_sessions 
WHERE rn = 1;
```

**David Martinez:** Хорошая структура. Один вопрос по оптимизации - это может быть медленно с большими наборами данных. Есть идеи, как улучшить производительность?

**Michael Thompson:** Эм, может быть... добавить индексы на user_id и временные метки? Я не уверен насчет более продвинутых техник оптимизации.

**Amanda Rodriguez:** Это начало. Мы также используем техники вроде предварительной агрегации данных и партиционирования. Это вещи, которым вы научитесь на работе.

## Качество Данных и Решение Проблем

**David Martinez:** Последний сценарий. Вы настраиваете дашборд и замечаете, что коэффициенты конверсии внезапно упали на 50% вчера, но рекламные расходы остались прежними. Как бы вы это расследовали?

**Michael Thompson:** Я бы начал с проверки, есть ли проблемы с качеством данных:
1. Все ли источники данных все еще подключаются правильно?
2. Сломался ли код трекинга на сайте?
3. Есть ли какие-либо необычные паттерны в данных, которые могут указывать на удаление дубликатов или отсутствующие данные?
4. Проверить, изменилось ли определение конверсий
5. Искать любые внешние факторы, такие как простой сайта

**Amanda Rodriguez:** Хороший систематический подход. Какие SQL запросы вы могли бы запустить, чтобы проверить проблемы с качеством данных?

**Michael Thompson:** Я бы сравнил количество строк день ко дню, проверил на null значения в ключевых полях, может быть, посмотрел на количество уникальных пользователей, чтобы увидеть, работает ли трекинг...

```sql
-- Проверить ежедневное количество строк
SELECT DATE(event_time) as date, COUNT(*) as events
FROM events 
WHERE event_time >= CURRENT_DATE - 7
GROUP BY DATE(event_time)
ORDER BY date;

-- Проверить на отсутствующие значения
SELECT COUNT(*) as total_rows,
       COUNT(user_id) as non_null_users,
       COUNT(session_id) as non_null_sessions
FROM events 
WHERE DATE(event_time) = CURRENT_DATE - 1;
```

**David Martinez:** Именно такие запросы мы бы запустили. Ваша методология дебаггинга здравая.

## Завершение

**Amanda Rodriguez:** Спасибо, Майкл. В целом, ваши основы SQL солидны, и ваш подход к решению проблем хорош. Основные области для роста были бы оптимизация производительности и обработка сложных граничных случаев.

**Michael Thompson:** Я ценю обратную связь. Эти сценарии сложнее, чем то, с чем я работаю ежедневно, но я вижу паттерны. Я воодушевлен возможностью изучить эти продвинутые техники.

**David Martinez:** Мы обсудим внутри и вернемся к вам скоро. Спасибо за ваше время!

---

## Оценка Технического Интервью

**Владение SQL:** 3/5 - Солидные основы, нужно работать над оптимизацией
**Решение Проблем:** 4/5 - Хороший систематический подход
**Понимание Атрибуции:** 3/5 - Схватывает концепции, ограниченный опыт
**Осведомленность о Качестве Данных:** 4/5 - Хорошая методология дебаггинга
**Оконные Функции:** 3/5 - Понимает основы, нужна практика
**Оптимизация Производительности:** 2/5 - Ограниченный опыт с большими наборами данных

**Общее Техническое Соответствие:** Умеренное - имеет потенциал, но потребуется значительное менторство

---

*Примечание к шаблону: Это интервью демонстрирует кандидата с хорошими основами, но пробелами в продвинутом SQL и оптимизации производительности. Показывает, как оценивать техническую глубину, выявляя зоны роста.*
